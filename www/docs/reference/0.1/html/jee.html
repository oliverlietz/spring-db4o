<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;1.&nbsp;Pitchfork: Spring JEE Support (M2)</title><link rel="stylesheet" href="../styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><link rel="home" href="index.html" title="Pitchfork: Spring JEE Support"><link rel="up" href="index.html" title="Pitchfork: Spring JEE Support"><link rel="previous" href="index.html" title="Pitchfork: Spring JEE Support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;1.&nbsp;Pitchfork: Spring JEE Support (M2)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="index.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;</td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jee"></a>Chapter&nbsp;1.&nbsp;Pitchfork: Spring JEE Support (M2)</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jee-introduction"></a>1.1.&nbsp;Introduction</h2></div></div><div></div></div><p><span class="emphasis"><em>EJB 3.0 (JSR 220)</em></span>, along with <span class="emphasis"><em>Common
    Annotations for the Java Platform (JSR 250)</em></span>, define a basic set
    of annotations for resource injection and interception, as part of the
    Java EE 5.0 specification release. Java EE 5.0 supports a limited subset
    of Dependency Injection (DI) called <span class="emphasis"><em>Resource
    injection</em></span> which provide allows injection of objects from the
    JNDI environment, such as other Java EE components.</p><p>Pitchfork is an Apache License open source project developed
    collaboratively by Interface21 and BEA Systems, as an add-on for
    Spring.</p><p>The aims of the Pitchfork project are twofold:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>To provide a basis for implementation of these new
          features in Java EE 5.0 in existing application servers</em></span>,
          on the basis of Spring's powerful, extensible DI and AOP
          functionality. An important advantage for users of containers that
          take this route is that they can easily make use of Spring features
          that add value beyond the present state of the Java EE
          specification: examples include DI features such as constructor
          injection, injection of primitive and complex types; access to
          existing Spring configurations; ability to work easily with code
          that does not include Java EE 5.0 annotations; and access to a far
          more powerful and elegant AOP model.</p></li><li><p><span class="emphasis"><em>To support Java EE 5.0 annotations inside the Spring
          container</em></span>, allowing classes authored to the EJB 3 and
          Java EE programming model to be reused with minimal changes (if any)
          inside Spring-managed applications. It is also possible to mix and
          match these elements of the Java EE 5.0 programming model with the
          richer and more powerful capabilities offered by Spring.</p></li></ul></div><p><span class="emphasis"><em>This project allows elements of the Java EE 5.0
    programming model to be used in Spring; it is not a full implementation of
    the Java EE 5.0 specifications, nor is that its goal. It is possible that
    further annotations will be supported in future releases (depending on
    user feedback); however, while Java EE 5.0 servers may use this project in
    their implementation of the Java EE specifications, Pitchfork itself will
    not become a full JEE application server. </em></span></p><p>This support is used internally in WebLogic Server (since May, 2006)
    to implement resource injection across Java EE components, and resource
    injection and interception in EJB 3.0 and components. It is also usable
    outside the WebLogic platform, as a simple add-on to Spring, with no
    dependencies besides Spring itself. This project requires the version of
    Spring JAR it ships with, or Spring 2.0 RC1 or above.</p><p>To understand how this support works, consider the following
    <span class="emphasis"><em>@Resource</em></span> annotation:</p><pre class="programlisting">public class SomeBean {

 private DataSource myDB;

 @Resource(name="jdbc/myCustomDB")
 public void setMyDB(DataSource myDB)
 {
    this.myDB = myDB;
 }
...
}</pre><p>This corresponds to an implicit (or explicit) Spring bean definition
    like this:</p><pre class="programlisting">&lt;beans&gt;
 ...
 &lt;bean id="myBean" class="...SomeBean"&gt;
   &lt;property name="myOtherDB"&gt;
      &lt;jee:jndi-lookup jndi-name="jdbc/myCustomDB" /&gt;
   &lt;/property&gt;
 &lt;/bean&gt;
...
&lt;/beans&gt;</pre><p>At the moment, Spring JEE support understands the following
    annotations, which are part of the JSR 250 and JSR 220: </p><div class="itemizedlist"><ul type="disc"><li><p>JSR 250 injection annotations (javax.annotation):
          @PostCostruct, @PreDestroy and @Resource</p></li><li><p>EJB3 interception annotations (javax.interceptor):
          @AroundInvoke, @ExcludeClassInterceptors,
          @ExcludeDefaultInterceptors, @Interceptors, @Invocation</p></li><li><p>EJB3 transaction annotations (javax.ejb): @Stateless,
          @ApplicationException and @TransactionAttribute</p></li><li><p>EJB3 injection annotation (javax.ejb): @EJB (since M2)</p></li></ul></div><p> In short, Spring can understand Java EE 5.0 injection,
    interception and transactional metadata.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bootstrapping"></a>1.2.&nbsp;Bootstrapping</h2></div></div><div></div></div><p>There are several ways to activate the Pitchfork Java EE 5.0
    programming model support in Spring: </p><div class="itemizedlist"><ul type="disc"><li><p>Through specific <span class="emphasis"><em>PostProcessor</em></span>s:</p><pre class="programlisting">&lt;beans&gt;
  &lt;bean class="org.springframework.jee.config.JeeBeanFactoryPostProcessor"/&gt;
  &lt;bean id="bean" class="org.springframework.jee.inject.InterceptedBean"/&gt;
&lt;/beans&gt;</pre><p>The <span class="emphasis"><em>JeeBeanFactoryPostProcessor</em></span> will
          analyze all the beans declared by the bean factory in which it is
          declared and will add the appropriate injections and/or
          interceptions. Simply adding this post processor will change the
          behaviour of the Spring container overall and it is the recommended
          way to use Pitchfork. This is a common extension point that should
          be familiar to Spring users.</p><p>Pitchfork M2 adds
          <span class="emphasis"><em>JeeEjbBeanFactoryPostProcessor</em></span> which extends
          <span class="emphasis"><em>JeeBeanFactoryPostProcessor</em></span> and adds support
          for @EJB annotations:</p><pre class="programlisting">&lt;beans&gt;
 &lt;!-- ejb post processor --&gt;
 &lt;bean class="org.springframework.jee.ejb.config.JeeEjbBeanFactoryPostProcessor"/&gt;
&lt;/beans&gt;</pre></li><li><p>By using <span class="emphasis"><em>Bootstrap</em></span> or
          <span class="emphasis"><em>EjbBootstrap</em></span> classes:</p><pre class="programlisting">Bootstrap bootstrap = new Bootstrap();
ApplicationContext applicationContext = bootstrap.deploy();
Bean myBean = (Bean) applicationContext.getBean("myBeanName");
...</pre><p>-- or --</p><pre class="programlisting">EjbBootstrap bootstrap = new EjbBootstrap();
String[] springLocations = new String[] { "classpath:org/springframework/jee/server/springExternal.xml" };
ComponentContributor contributor = new EjbAnnotationComponentContributor(ejbClass)
ApplicationContext context = bootstrap.deploy(springLocations, 
                                                new DefaultResourceLoader(), contributor, new DeploymentUnitMetadata());
...</pre><p>The Bootstrap classes are mainly used by containers that need
          control over the deploying process. They offer several methods for
          specifying what locations, resource loader (ex: classpath or
          filesystem based) and what deploymentUnit metadata to be
          used.</p><p>This style of use is not primarily intended for developers
          using Spring, but for those embedding this functionality within an
          existing container (such as WebLogic Server).</p><p>The
          <span class="emphasis"><em><tt class="literal">DeploymentUnitMetadata</tt></em></span>
          represents a programmatic way of specifing EJB3 descriptor
          properties like default interceptors or application exceptions which
          complement the annotations. Applications that can understand EJB3
          XML files can plug this information into the JEE support through
          this class.</p><p><span class="bold"><b>Note</b></span>: It is recommended that
          <span class="emphasis"><em>JeeBeanFactoryPostProcessor</em></span> and
          <span class="emphasis"><em>JeeEjbBeanFactoryPostProcessors</em></span> are used since
          Pitchfork internals may change until a final release.</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="specs"></a>1.3.&nbsp;Specification support</h2></div></div><div></div></div><p>While JSR 250 is straight forward and it be used in all application
    types, EJB3-style interception and transaction are just a part of the full
    JSR 220 that is usually implemented by application containers. Below are
    listed the existing issues and limitations of the project:</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ejb3-descriptors"></a>1.3.1.&nbsp;EJB 3.0 deployment descriptors</h3></div></div><div></div></div><p>EJB deployment descriptors (optional XML configuration containing
      information beyond Java annotations) are not understood by default by
      Spring or this add-on project. Only annotation processing is performed
      out of the box. Spring's own metadata is both simpler and far more
      powerful than the EJB 3 XML metadata, so there would be little
      motivation for using this style of configuration in a Spring
      application.</p><p>However, through the <tt class="literal">DeploymentUnitMetadata</tt>,
      third parties can add information about the default interceptors or
      application exceptions. See the javadocs for more information on what
      properties can be set. Note that XML descriptors contain a lot of
      information which is important only to the application server and
      irelevant to Spring (like resource-env).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="interception-spec"></a>1.3.2.&nbsp;EJB 3.0-style interception</h3></div></div><div></div></div><p>Ptichfork allows the use of EJB 3.0 style interceptors (annotated
      with <tt class="literal">@AroundInvoke</tt>) to be used in a Spring container.
      Note that the lifecyle of the interceptor is tightly bound to that of
      the bean it intercepts. Spring will fulfill this contract but will not
      support activate or passivate calls (specified by @PostActivate or
      @PreDestroy). However, hooks are provided so that the outer container
      which manages the bean lifespan, can inform Spring of these events.
      Default interceptors can be added programatically through the
      <tt class="literal">DeploymentUnitMetadata</tt> class.<i><span class="remark"></span></i></p><p>It is possible to mix and match EJB 3 interception with both
      Spring AOP and Spring 2.0 @AspectJ style functionality. However, in
      almost all cases either of the latter programming models is wholly
      superior.</p><p><i><span class="remark">We recommend the @AspectJ programming model in general
      with Spring 2.0 and above: it is both more elegant and far more powerful
      than any interception style model. For example, it provides true
      pointcuts (the core concept of AOP); does not effectively force the use
      of annotations across a codebase to be used in conjuction with aspects;
      offers far greater potential for reuse; and offers type safety and
      robust access to parameters and return types through argument binding.
      Note that Spring 2.0 also offers an equivalent XML concise namespace
      schema. For further details about the @AspectJ programming model and XML
      pointcut expressions, see the AOP chapters of the Spring 2.0 Reference
      Manual.</span></i></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-spec"></a>1.3.3.&nbsp;EJB 3.0 style declarative transaction management</h3></div></div><div></div></div><p>EJB3-style transactions are understood and applied using Spring
      transaction support. The application exceptions are parsed at runtime
      and, based on their annotation (@ApplicationException), the transaction
      will be commited or rolled back. Transactions are created for beans that
      are considered session beans: that is, which contain the @Stateless and
      @Stateful annotations. Again, the
      <tt class="literal">DeploymentUnitMetadata</tt> class can be used to add more
      application exceptions besides the ones declared already through
      annotations. Because Spring's transaction support is used under the
      covers, the EJB style transaction management model is thus supported in
      any environment: not just a JTA environment.</p><p><i><span class="remark">Note that the functionality provided by the EJB 3
      @TransactionAttribute annotation is a subset of that offered by Spring's
      own Transactional annotation or other Spring metadata. In particular,
      the EJB 3.0 notion of annotating an exception, rather than a use case,
      to convey rollback information, is arguably flawed. We do not recommend
      that Spring users use this model by choice, but see it as a mechanism by
      which components that use this annotation can benefit from superior
      Spring functionality. </span></i></p><p>Spring's own transaction annotation support carries more
      information than EJB transaction metadata and also can support nested
      transactions on participating resource managers and per use case
      rollback rules.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e204"></a>1.3.4.&nbsp;EJB 3.0 style injection</h3></div></div><div></div></div><p>Since M2, Pitchfork supports @EJB annotations: the object is
      looked inside JNDI and falls back to Spring applicationContext. However,
      remote interface lookups are not yet supported.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e209"></a>1.4.&nbsp;Architecture</h2></div></div><div></div></div><p>The architecture is based on the new ability in Spring 2.0 to attach
    arbitrary metadata to Spring bean definitions. This new extension point is
    combined with the existing extension point of a <span class="emphasis"><em>bean post
    processor</em></span> (an object that can react to the instantiation of
    each bean in a Spring context).</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e217"></a>1.4.1.&nbsp;Metadata</h3></div></div><div></div></div><p>At the core of the Spring JEE project are the metadata classes.
      All bean definitions contained by Spring bean factory are passed through
      a chain of processors which, based on various information (usually
      annotations), create specific metadata that is later on used for
      applying the injection, creating the interception or applying
      transactional behavior:</p><p></p><div class="mediaobject"><img src="images/metadata.png"></div><p>It is important to note that metadata is attached to a Spring bean
      definition as a custom attribute (a feature of Spring 2.0). Each
      metadata class holds Java EE specific information regarding the bean
      definition it is attached to, as well as methods to apply it.</p><p><span class="emphasis"><em>Jsr250Metadata</em></span> is the base for the current
      metadata classes - it contains the injection and the lifecycle methods
      for constructing and destroying the objects along with references to the
      loading application context, the bean definition registry, the
      deployment unit metadata and the inspected bean class. It also contains
      hooks to invoke lifecycle methods on a class instance and apply
      injection.</p><p><span class="emphasis"><em>IncerceptionMetadata</em></span> extends the
      <span class="emphasis"><em>Jsr250Metadata</em></span> and provides hooks for applying
      EJB3-style interception. It can handle applying the default
      interceptors, super interceptors and exclusion of interceptors (based on
      the inheritance algorithm specified in JSR 250). It also contains hooks
      for allowing custom interceptors to be added in the weaving
      process.</p><p><span class="emphasis"><em>InterceptorMetadata</em></span> contains information
      about interceptor beans since they can also be subject to interception
      and injection. <span class="emphasis"><em>InterceptorMetadata</em></span> hold
      characteristics like being a default or class interceptor and are
      usually part of an <span class="emphasis"><em>InterceptionMetadata</em></span>
      class.</p><p><span class="emphasis"><em>TransactionMetadata</em></span> is used for holding
      transactional behavior, like declared application exceptions or
      transactional methods and transactional attributes. It extends the
      <span class="emphasis"><em>InterceptionMetadata</em></span> class only to add
      transactional behavior (through
      <tt class="literal">TransactionInterceptor</tt> and a customized
      <tt class="literal">NameMatchTransactionAttributeSource</tt>).</p><p><span class="emphasis"><em>EjbMetadata</em></span> is focused on EJB3 functionality
      but at this point, it is not yet used. (A WebLogic-specific subclass of
      <tt class="literal">TransactionMetadata</tt> is used internally in WebLogic
      Server.)</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e269"></a>1.4.2.&nbsp;ComponentContributor</h3></div></div><div></div></div><p>However, metadata has to be created after the bean definitions
      have been read, and later on applied. This is achieved through the
      <span class="emphasis"><em>JeeBeanFactoryPostProcessor</em></span> which in return, relies
      on <span class="emphasis"><em>ComponentContributor</em></span> to extract the metadata.
      <span class="emphasis"><em>ComponentContributor</em></span> interface defines the contract
      for adding Jee metadata to an existing Spring context - by default, Bean
      DefinitionAnnotationComponentContributor is used. The process of binding
      the discovered metadata to the bean definition is done through the
      <span class="emphasis"><em>Enricher</em></span> class which also validates the metadata
      (for example, verifies that stateless beans contain a business
      interface).</p><div class="mediaobject"><img src="images/component-contributors.png"></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e289"></a>1.4.3.&nbsp;Metadata Processors</h3></div></div><div></div></div><p>The discovery metadata process executes several processors which
      create a chain.</p><div class="mediaobject"><img src="images/metadata-processors.png"></div><p>At the moment, there are three metadata processors available out
      of the box:</p><div class="orderedlist"><ol type="1"><li><p>Jsr250Processor - which inspects the classes for the injection
          and lifecycle annotations defined by JSR 250</p></li><li><p>InterceptionProcessor - which handles the EJB3 interception
          annotations. Since the interceptors resulted can also have JSR 250
          annotations, the InterceptionProcess uses internally a
          Jsr250Processor to inspect them.</p></li><li><p>TransactionProcessor - which is aware of the EJB3 @Stateful
          and @Stateless annotations as well as the transaction
          attributes.</p></li></ol></div><p>These three processors are chained inside
      <span class="emphasis"><em>ChainedProcessorContributor</em></span> and form the default
      processing chain. It is possible however, to pass a customized chain
      through <span class="emphasis"><em>setMetadataProcessors(List&lt;MetadataProcessor&gt;
      processors)</em></span> method. The resulting metadatas are attached to
      the bean definition by the enricher and later processed.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e317"></a>1.4.4.&nbsp;Metadata PostProcessors</h3></div></div><div></div></div><p>Metadata PostProcessors are used for translating the Jee metadata
      into injection, interceptors or transaction definitions:</p><div class="mediaobject"><img src="images/metadata-postprocessors.png"></div><p><span class="emphasis"><em>Jsr250MetadataBeanPostProcessor</em></span> extracts
      <span class="emphasis"><em>Jsr250Metadata</em></span> object from each bean definition and
      applies injection and hooks for construction and destruction, while
      <span class="emphasis"><em>InterceptionMetadataBeanPostProcessor</em></span> takes care of
      interception. It is recommended that third parties, even when using
      composition, reuse the
      <span class="emphasis"><em>MetadataDrivenBeanPostProcessorSupport</em></span> as a base
      class for reading bean definition metadata.
      <span class="emphasis"><em>TransactionMetadata</em></span> does not require a special
      metadata PostProcessor since it is a subclass of
      <span class="emphasis"><em>InterceptionMetadata</em></span> which is already has a
      Metadata PostProcessor.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e344"></a>1.4.5.&nbsp;Metadata Validation</h3></div></div><div></div></div><p>Pitchfork defines an extensible mechanism for validation, meaning
      enforcement of rules in the relevant Java EE 5.0 specifications. This is
      designed to allow the addition and autodetection of specification rules
      and error messages unique to a particular host environment, such as an
      application server.</p><p>To execute metadata validation, the current package provides two
      interfaces:</p><div class="mediaobject"><img src="images/validation-rules_service.png"></div><p></p><div class="orderedlist"><ol type="1"><li><p>ValidationService - which defines element that can execute
          validation and</p></li><li><p>SpecificationRule - which defines a validation rule and its
          relationship to the JSR specifications.</p></li></ol></div><p>By default, the boostrap classes will use the
      <span class="emphasis"><em>AutodetectValidationService</em></span> which looks for
      <span class="emphasis"><em>@SpecificationRules</em></span> annotations which marks a
      component as a validation rule. Internally,
      <span class="emphasis"><em>ReflectiveRuleBasedValidationService</em></span> is used to
      execute the validation method from the detected
      <span class="emphasis"><em>SpecificationRule</em></span>. See the
      <span class="emphasis"><em>InterceptionRules</em></span> and
      <span class="emphasis"><em>Jsr250Rules</em></span> as examples for extending the
      out-of-the-box validation rules.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;</td></tr><tr><td width="40%" align="left" valign="top">Pitchfork: Spring JEE Support&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;</td></tr></table></div></body></html>